#!/usr/bin/env node

"use strict" ;

const lib = require( '..' ) ;
const Palette = lib.Palette ;
const FixedPalette = lib.FixedPalette ;
const Color = lib.Color ;

const kungFig = require( 'kung-fig' ) ;

const fs = require( 'fs' ) ;



// Argument management

if ( process.argv.length < 3 ) {
	console.error( "Expecting a palette definition file (.kfg)" ) ;
	process.exit( 1 ) ;
}

var sourceFile = process.argv[ 2 ] ,
	exportType = process.argv[ 3 ] ,
	outputFile = process.argv[ 4 ] ;



// Generate the palette

var config = kungFig.load( sourceFile ) ;



// Exporters

var exporters = {} ;

exporters.display = () => {
	let fixedPalette = new FixedPalette( config ) ;
	console.log( "Color count: " , fixedPalette.indexed.length ) ;
	console.log( "Indexed palette: " , fixedPalette.indexed ) ;
	console.log( "Names: " , fixedPalette.named ) ;
} ;



exporters['index-json'] = () => {
	let fixedPalette = new FixedPalette( config ) ;
	let content = JSON.stringify( fixedPalette.indexed ) ;

	if ( outputFile ) { fs.writeFileSync( outputFile , content ) ; }
	else if ( content ) { console.log( content ) ; }
} ;



exporters['names-json'] = () => {
	let fixedPalette = new FixedPalette( config ) ;
	let content = JSON.stringify( fixedPalette.named ) ;

	if ( outputFile ) { fs.writeFileSync( outputFile , content ) ; }
	else if ( content ) { console.log( content ) ; }
} ;



exporters['pixelorama'] = () => {
	let fixedPalette = new FixedPalette( config , 'chroma' ) ;

	let colors = fixedPalette.indexed.map( ( chroma , index ) => ( {
		color: '(' + chroma.rgba().map( ( v , i ) => i < 3 ? v / 255 : v ).join( ', ' ) + ')' ,
		index
	} ) ) ;

	let data = {
		colors ,
		comment: "Generated by Palette Shade" ,
		width: Math.min( 32 , colors.length ) ,
		height: Math.ceil( colors.length / 32 )
	} ;

	let content = JSON.stringify( data , undefined , ' ' ) ;

	if ( outputFile ) { fs.writeFileSync( outputFile , content ) ; }
	else if ( content ) { console.log( content ) ; }
} ;



exporters['png'] = () => {
	exportPng( fixedPalette => vline( fixedPalette , 1 , 1 ) ) ;
} ;

exporters['vline-png'] = () => {
	exportPng( fixedPalette => vline( fixedPalette , 1 , 32 ) ) ;
} ;

exporters['thick-vline-png'] = () => {
	exportPng( fixedPalette => vline( fixedPalette , 16 , 128 ) ) ;
} ;

exporters['hline-png'] = () => {
	exportPng( fixedPalette => hline( fixedPalette , 1 , 32 ) ) ;
} ;

exporters['thick-hline-png'] = () => {
	exportPng( fixedPalette => hline( fixedPalette , 16 , 128 ) ) ;
} ;



function vline( fixedPalette , thickness = 1 , length = 32 ) {
	let imgArray = [] ;
	let width = fixedPalette.indexed.length * thickness ;
	let height = length ;

	for ( let y = 0 ; y < height ; y ++ ) {
		for ( let x = 0 ; x < width ; x ++ ) {
			let colorIndex = Math.round( x * fixedPalette.indexed.length / width ) ;
			imgArray[ y * width + x ] = colorIndex ;
		}
	}
	
	return [ width , height , imgArray ] ;
}



function hline( fixedPalette , thickness = 1 , length = 32 ) {
	let imgArray = [] ;
	let width = length ;
	let height = fixedPalette.indexed.length * thickness ;

	for ( let y = 0 ; y < height ; y ++ ) {
		for ( let x = 0 ; x < width ; x ++ ) {
			let colorIndex = Math.round( y * fixedPalette.indexed.length / height ) ;
			imgArray[ y * width + x ] = colorIndex ;
		}
	}
	
	return [ width , height , imgArray ] ;
}



async function exportPng( dataFn ) {
	if ( ! outputFile ) {
		console.error( "The 'png' exporter requires an output file" ) ;
		process.exit( 1 ) ;
	}

	//const PngToy = require( './pngtoy.min.js' ) ;
	const indexedPng = require( 'indexed-png' ) ;
	let fixedPalette = new FixedPalette( config , 'rgb' ) ;

	// First create the palette
	let paletteArray = [] ;
	
	for ( let color of fixedPalette.indexed ) {
		paletteArray.push( ( color.r << 16 ) | ( color.g << 8 ) | ( color.b ) ) ;
	}
	
	let [ width , height , imgArray ] = dataFn( fixedPalette ) ;
	
	const buffer = Buffer.from( imgArray ) ;
	fs.writeFileSync( outputFile , (await indexedPng.createPNG(buffer, paletteArray, width, height)));
}



if ( exporters[ exportType ] ) { exporters[ exportType ]() ; }
else { exporters.display() ; }

